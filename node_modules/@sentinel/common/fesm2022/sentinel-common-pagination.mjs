import { BehaviorSubject } from 'rxjs';

function isPaginatedElements(object) {
    return 'elements' in object && 'pagination' in object;
}

class PaginatedResource {
    constructor(elements, pagination) {
        this.elements = elements;
        this.pagination = pagination;
    }
}

function isOffsetPagination(pagination) {
    return pagination.page !== undefined;
}
function isCursorPagination(pagination) {
    const maybeCursorPagination = pagination;
    return (maybeCursorPagination.curr !== undefined &&
        maybeCursorPagination.next !== undefined &&
        maybeCursorPagination.previous !== undefined);
}

class PaginationBase {
    constructor(numberOfElements, size, totalElements) {
        this.numberOfElements = numberOfElements;
        this.size = size;
        this.totalElements = totalElements;
    }
}

class CursorPagination extends PaginationBase {
    constructor(curr, numberOfElements, size, totalElements, next, previous) {
        super(numberOfElements, size, totalElements);
        this.curr = curr;
        this.next = next;
        this.previous = previous;
    }
}

class OffsetPagination extends PaginationBase {
    constructor(page, numberOfElements, size, totalElements, totalPages) {
        super(numberOfElements, size, totalElements);
        this.page = page;
        this.totalPages = totalPages;
    }
}

function isOffsetEvent(event) {
    return event.page !== undefined;
}
function isCursorEvent(event) {
    return event.cursor !== undefined;
}

class PaginationBaseEvent {
    constructor(size, sort, sortDir) {
        this.size = size;
        this.sort = sort;
        this.sortDir = sortDir;
    }
}

class CursorPaginationEvent extends PaginationBaseEvent {
    constructor(cursor, size, sort, sortDir) {
        super(size, sort, sortDir);
        this.cursor = cursor;
    }
}

class OffsetPaginationEvent extends PaginationBaseEvent {
    constructor(page, size, sort, sortDir) {
        super(size, sort, sortDir);
        this.page = page;
    }
}

class RequestedPaginationManager {
    constructor(pageSize, initial) {
        this.defaultPageSize = pageSize;
        const event = initial ?? this.createInitialPagination();
        this.pagination$ = new BehaviorSubject(event);
    }
    update(pagination) {
        if (this.hasSortingChanged(pagination) || this.hasPageSizeChanged(pagination)) {
            this.resetPosition(pagination);
        }
        else {
            this.pagination$.next({ ...pagination });
        }
    }
    resetSize() {
        const curr = this.pagination$.getValue();
        if (curr) {
            curr.size = this.defaultPageSize;
            this.pagination$.next({ ...curr });
        }
    }
    hasSortingChanged(next) {
        const curr = this.pagination$.getValue();
        if (!curr) {
            return false;
        }
        const isDifferent = next.sort !== curr.sort || next.sortDir !== curr.sortDir;
        if (isDifferent) {
            return (!this.isDifferentEmptyValues(next.sort, curr.sort) || !this.isDifferentEmptyValues(next.sortDir, curr.sortDir));
        }
        return false;
    }
    hasPageSizeChanged(pagination) {
        const curr = this.pagination$.getValue();
        if (curr) {
            return pagination.size !== curr.size;
        }
        else {
            return false;
        }
    }
    isDifferentEmptyValues(valueA, valueB) {
        return ((valueA === undefined || valueA === null || valueA === '') &&
            (valueB === undefined || valueB === null || valueB === ''));
    }
}

class CursorRequestedPaginationManager extends RequestedPaginationManager {
    constructor(pageSize, initial) {
        super(pageSize, initial);
    }
    createInitialPagination() {
        return new CursorPaginationEvent(null, this.defaultPageSize, undefined, undefined);
    }
    resetPosition(onEvent) {
        const pagination = onEvent ?? this.pagination$.getValue();
        pagination.cursor = null;
        this.pagination$.next({ ...pagination });
    }
}

class OffsetRequestedPaginationManager extends RequestedPaginationManager {
    constructor(pageSize, initial) {
        super(pageSize, initial);
    }
    createInitialPagination() {
        return new OffsetPaginationEvent(0, this.defaultPageSize, undefined, undefined);
    }
    resetPosition(onEvent) {
        const curr = onEvent ?? this.pagination$.getValue();
        curr.page = 0;
        this.pagination$.next({ ...curr });
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { CursorPagination, CursorPaginationEvent, CursorRequestedPaginationManager, OffsetPagination, OffsetPaginationEvent, OffsetRequestedPaginationManager, PaginatedResource, PaginationBase, PaginationBaseEvent, RequestedPaginationManager, isCursorEvent, isCursorPagination, isOffsetEvent, isOffsetPagination, isPaginatedElements };
//# sourceMappingURL=sentinel-common-pagination.mjs.map

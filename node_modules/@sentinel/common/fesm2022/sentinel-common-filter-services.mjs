import equal from 'fast-deep-equal/es6';
import { BehaviorSubject, from, merge, combineLatest } from 'rxjs';
import { distinctUntilChanged, shareReplay, tap, map, concatMap, skip } from 'rxjs/operators';
import { isArray, QueryParamsNavigationQueueService, isDate, slugify, slugifyDate, deslugify, deslugifyTimestamp } from '@sentinel/common/utils';
import { ActivatedRoute } from '@angular/router';
import { inject } from '@angular/core';

class FilterService {
    constructor(ignoredKeys = [], ignoredActiveFilterKeys = ignoredKeys) {
        this.ignoredKeys = ignoredKeys;
        this.ignoredActiveFilterKeys = ignoredActiveFilterKeys;
        this.EMPTY_FILTER = this.createEmptyFilter();
        this.filterLocalStateSubject$ = new BehaviorSubject(this.EMPTY_FILTER);
        this.filterSubject$ = new BehaviorSubject(this.filterLocalStateSubject$.getValue());
        this.filterLocalState$ = this.filterLocalStateSubject$.asObservable().pipe(distinctUntilChanged((prev, curr) => equal(prev, curr)), shareReplay({ refCount: true }));
        this.filter$ = this.filterSubject$.asObservable().pipe(distinctUntilChanged((prev, curr) => equal(prev, curr)), tap((filter) => this.filterLocalStateSubject$.next(filter), shareReplay({ refCount: true })));
        this.isEmpty$ = this.filter$.pipe(map((filter) => this.areFilterKeysEqual(filter, this.EMPTY_FILTER)), distinctUntilChanged());
        this.activeFiltersCount$ = this.filterLocalState$.pipe(map((filter) => this.calculateActiveFiltersCount(filter)), distinctUntilChanged());
    }
    get() {
        return this.filterSubject$.getValue();
    }
    update(filter) {
        const curr = { ...this.filterLocalStateSubject$.getValue() };
        this.filterLocalStateSubject$.next({ ...curr, ...filter });
    }
    updateAndSubmit(filter) {
        this.update(filter);
        this.submit();
    }
    submit() {
        this.filterSubject$.next(this.filterLocalStateSubject$.getValue());
    }
    clear() {
        const currFilter = this.get();
        const emptyFilter = { ...this.EMPTY_FILTER };
        this.ignoredKeys.forEach((ignoredKey) => {
            if (currFilter[ignoredKey] !== undefined && currFilter[ignoredKey] !== null) {
                emptyFilter[ignoredKey] = currFilter[ignoredKey];
            }
        });
        this.filterLocalStateSubject$.next(emptyFilter);
        this.submit();
    }
    set(filter) {
        this.filterLocalStateSubject$.next(filter);
    }
    areFilterKeysEqual(prev, curr, compareIgnoredKeys = false) {
        const prevCopy = { ...prev };
        const currCopy = { ...curr };
        if (!compareIgnoredKeys) {
            this.ignoredKeys.forEach((ignoredKey) => {
                delete prevCopy[ignoredKey];
                delete currCopy[ignoredKey];
            });
        }
        return equal(currCopy, prevCopy);
    }
    calculateActiveFiltersCount(filter) {
        if (typeof filter === 'object') {
            let count = 0;
            const narrowedFilter = filter;
            Object.keys(narrowedFilter).forEach((key) => {
                if (!this.ignoredActiveFilterKeys.includes(key) &&
                    narrowedFilter[key] !== undefined &&
                    narrowedFilter[key] !== null &&
                    narrowedFilter[key] !== '' &&
                    (!isArray(narrowedFilter[key]) || narrowedFilter[key].length > 0)) {
                    count++;
                }
            });
            return count;
        }
        else {
            return 0;
        }
    }
}

class FilterChipsService {
    constructor(filterService) {
        this.filterService = filterService;
        this.chips$ = this.filterService.filter$.pipe(map((filter) => this.createChips(filter)));
    }
}

class QueryParamFilterService extends FilterService {
    constructor(ignoredKeys = [], ignoredActiveFilterKeys = ignoredKeys) {
        super(ignoredKeys, ignoredActiveFilterKeys);
        this.queryParamsQueueService = inject(QueryParamsNavigationQueueService);
        this.activatedRoute = inject(ActivatedRoute);
        this.filter$ = this.createFilterObservable();
    }
    toQueryParams(filter) {
        const params = {};
        const entries = Object.entries(filter);
        entries
            .filter((entry) => !this.ignoredKeys.map((key) => key.toString()).includes(entry[0]))
            .forEach((entry) => {
            if (isDate(entry[1])) {
                params[entry[0]] = this.slugifyDate(entry[1]);
            }
            else if (isArray(entry[1])) {
                params[entry[0]] = entry[1].map((entry) => this.slugify(entry?.toString()));
            }
            else {
                params[entry[0]] = this.slugify(entry[1]?.toString());
            }
        });
        return params;
    }
    updateQueryParams(filter) {
        return from(this.queryParamsQueueService.enqueue(this.toQueryParams(filter)));
    }
    slugify(value) {
        return slugify(value);
    }
    slugifyDate(value) {
        return slugifyDate(value);
    }
    deslugify(value) {
        return deslugify(value);
    }
    deslugifyTimestamp(value) {
        return deslugifyTimestamp(value);
    }
    getParamValue(paramMap, key) {
        return paramMap.get(key.toString());
    }
    createFilterObservable() {
        const fromRoute$ = this.fromRoute().pipe(tap((filter) => this.updateAndSubmit(filter)));
        const fromSubject$ = this.createFilterSubjectObservable();
        return merge(fromSubject$, fromRoute$).pipe(distinctUntilChanged((prev, curr) => this.areFilterKeysEqual(prev, curr, true)), concatMap((filter) => this.updateQueryParams(filter).pipe(map(() => filter))), shareReplay({ refCount: true }));
    }
    createFilterSubjectObservable() {
        // skip subject init from route
        return this.filterSubject$.asObservable().pipe(shareReplay({ refCount: true }), skip(1));
    }
    fromRoute() {
        return combineLatest([
            this.activatedRoute.queryParamMap,
            this.activatedRoute.paramMap,
            this.activatedRoute.data,
        ]).pipe(concatMap((routeAsyncAttrs) => this.createFilterFromRoute(routeAsyncAttrs[0], routeAsyncAttrs[1], routeAsyncAttrs[2])));
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { FilterChipsService, FilterService, QueryParamFilterService };
//# sourceMappingURL=sentinel-common-filter-services.mjs.map

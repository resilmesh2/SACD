import { InjectionToken } from '@angular/core';

/**
 * Injection token of the application's dynamic config. Can be useful for dynamic injection into other modules
 * Use as dependency for providing a config through injections token and configurableModuleFactory.
 */
const APP_CONFIG = new InjectionToken('SentinelConfig');
const appConfigFactory = appConfigFactoryFunc;
/**
 * App config provider. Provides dynamic config at runtime using a factory function.
 * USAGE EXAMPLE:
 *  @NgModule({
 *     declarations: [AppComponent],
 *     imports: [BrowserModule,],
 *     providers: [appConfigProvider]
 *     bootstrap: [AppComponent]
 *   })
 *  export class AppModule {}
 */
const appConfigProvider = { provide: APP_CONFIG, useFactory: appConfigFactory };
/**
 * Allows access to parts of a config dynamically, at runtime.
 * USAGE EXAMPLE:
 *  @NgModule({
 *   imports: [CommonModule, SentinelAuthModule.forRoot(null)],
 *   providers: [
 *     {
 *       provide: SentinelAuthConfig,
 *       useFactory: configurableModuleFactory<KypoConfig>('authConfig'),
 *       deps: [APP_CONFIG],
 *     },
 *   ],
 * })
 *  export class AuthModule {}
 */
const configurableModuleFactory = configurableModuleFactoryFunc;
function configurableModuleFactoryFunc(prop) {
    return (sentinelConfig) => sentinelConfig[prop];
}
function appConfigFactoryFunc() {
    return window.sentinelAppConfig;
}

/**
 * Replacement of Angular's environment constants. This environment supports populating its properties at the run-time
 * loaded from an external file, thus supporting a build once deploy many approach in Angular.
 * RECOMMENDED USAGE:
 * Wrap this class with custom class to avoid the need for providing type with each call to getConfig method.
 * For example:
 * export class MyDynamicEnvironment {
 *   public static getConfig(): MyCustomConfig {
 *     return DynamicEnvironment.getConfig<MyCustomConfig>();
 *   }
 * }
 *
 * Then access the config from application's code like:
 *
 * const config: MyCustomConfig = MyDynamicEnvironment.getConfig();
 *
 * vs
 *
 * const config: MyCustomConfig = DynamicEnvironment.getConfig<MyCustomConfig>();
 */
class DynamicEnvironment {
    static getConfig() {
        return window.sentinelAppConfig;
    }
    static setConfig(config) {
        window.sentinelAppConfig = config;
    }
}

/**
 * Custom bootstrapper. Fetches a config JSON file from provided url, parses it and sets it as dynamic environment before
 * bootstrapping provided module.
 * Optionally, custom platform can be provided. platformBrowserDynamic is used by default.
 */
class SentinelBootstrapper {
    static bootstrap(url, moduleType, platform, compilerOptions) {
        return fetch(url)
            .then((response) => response.json())
            .then((config) => {
            DynamicEnvironment.setConfig(config);
            return platform.bootstrapModule(moduleType, compilerOptions).catch((err) => {
                console.error(err);
                throw new Error(err);
            });
        })
            .catch((err) => {
            console.error(err);
            throw new Error(err);
        });
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { APP_CONFIG, DynamicEnvironment, SentinelBootstrapper, appConfigProvider, configurableModuleFactory };
//# sourceMappingURL=sentinel-common-dynamic-env.mjs.map

import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Optional, Inject } from '@angular/core';
import { distinctUntilChanged, shareReplay, tap, concatMap, map, take } from 'rxjs/operators';
import equal from 'fast-deep-equal/es6';
import { OffsetPaginationEvent, CursorPaginationEvent, isOffsetEvent, OffsetRequestedPaginationManager, isCursorEvent, CursorRequestedPaginationManager, OffsetPagination } from '@sentinel/common/pagination';
import * as i2 from '@sentinel/common/utils';
import { toQueryParams, propertyOf } from '@sentinel/common/utils';
import { from } from 'rxjs';
import * as i1 from '@angular/router';

const INIT_PAGINATION_EVENT_BASE_TOKEN = new InjectionToken('INIT_PAGINATION_EVENT_TOKEN');
const PAGINATION_TYPE_TOKEN = new InjectionToken('PAGINATION_TYPE_TOKEN');
const MAX_PAGINATION_SIZE_TOKEN = new InjectionToken('MAX_PAGINATION_SIZE_TOKEN');

class PaginationBaseInit {
    constructor(size, sort, sortDir) {
        this.size = size;
        this.sort = sort;
        this.sortDir = sortDir;
    }
}

class PaginationService {
    constructor(initPaginationBase, paginationType) {
        this.initPaginationBase = initPaginationBase;
        this.paginationType = paginationType;
        if (!paginationType) {
            this.paginationType = 'cursor';
        }
        this.INIT_PAGINATION = createInitPagination(this.paginationType ?? 'cursor', this.initPaginationBase);
        this.paginationManager = createPaginationManager(this.INIT_PAGINATION.size, this.INIT_PAGINATION, this.paginationType ?? 'cursor');
        this.pagination$ = this.paginationManager.pagination$.asObservable().pipe(distinctUntilChanged((prev, curr) => equal(prev, curr)), shareReplay({ refCount: true }));
    }
    get() {
        return this.paginationManager.pagination$.getValue();
    }
    update(pagination) {
        this.paginationManager.update(pagination);
    }
    resetPosition() {
        this.paginationManager.resetPosition();
    }
    resetSize() {
        this.paginationManager.resetSize();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: PaginationService, deps: [{ token: INIT_PAGINATION_EVENT_BASE_TOKEN, optional: true }, { token: PAGINATION_TYPE_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: PaginationService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: PaginationService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: PaginationBaseInit, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [INIT_PAGINATION_EVENT_BASE_TOKEN]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [PAGINATION_TYPE_TOKEN]
                }] }] });
function createInitPagination(paginationType, initPaginationBase) {
    const paginationBase = initPaginationBase ?? { size: 10, sort: undefined, sortDir: undefined };
    if (paginationType === 'offset') {
        return new OffsetPaginationEvent(0, paginationBase.size, paginationBase.sort, paginationBase.sortDir);
    }
    else if (paginationType === 'cursor') {
        return new CursorPaginationEvent(null, paginationBase.size, paginationBase.sort, paginationBase.sortDir);
    }
    else {
        throw new Error(`PaginationType does not match supported values 'offset' and 'cursor'`);
    }
}
function createPaginationManager(initSize, initPagination, paginationType) {
    if (paginationType === 'offset' && isOffsetEvent(initPagination)) {
        return new OffsetRequestedPaginationManager(initSize, initPagination);
    }
    else if (paginationType === 'cursor' && isCursorEvent(initPagination)) {
        return new CursorRequestedPaginationManager(initSize, initPagination);
    }
    else {
        throw new TypeError('Incompatible pagination type and initial pagination');
    }
}

class OffsetPaginationResolver {
    static resolve(queryData, paginationEvent) {
        const size = paginationEvent.size;
        return new OffsetPagination(paginationEvent.page, queryData.elementsCount, size, queryData.totalCount, Math.ceil(queryData.totalCount / size));
    }
}

class QueryParamPaginationService extends PaginationService {
    constructor(activatedRoute, queryParamsQueueService, initPaginationBase, paginationType, initMaxPaginationSize) {
        super(initPaginationBase, paginationType);
        this.activatedRoute = activatedRoute;
        this.queryParamsQueueService = queryParamsQueueService;
        this.initPaginationBase = initPaginationBase;
        this.paginationType = paginationType;
        this.initMaxPaginationSize = initMaxPaginationSize;
        if (!paginationType) {
            this.paginationType = 'cursor';
        }
        this.maxPaginationSize = initMaxPaginationSize ? initMaxPaginationSize : 100;
        this.pagination$ = this.createPaginationObservable();
    }
    updateQueryParams(pagination) {
        return from(this.queryParamsQueueService.enqueue(toQueryParams(pagination)));
    }
    createPaginationObservable() {
        return this.fromRoute().pipe(tap((pagination) => (this.paginationManager = createPaginationManager(this.INIT_PAGINATION.size, pagination, this.paginationType ?? 'cursor'))), concatMap(() => this.paginationManager.pagination$), concatMap((pagination) => this.updateQueryParams(pagination).pipe(map(() => pagination))), shareReplay({ refCount: true }));
    }
    fromRoute() {
        return this.activatedRoute.queryParamMap.pipe(take(1), map((paramMap) => this.paginationFromParamMap(paramMap)));
    }
    paginationFromParamMap(paramMap) {
        let pagination;
        if (this.paginationType === 'offset') {
            pagination = this.offsetPaginationFromParamMap(paramMap);
        }
        else if (this.paginationType === 'cursor') {
            pagination = this.cursorPaginationFromParamMap(paramMap);
        }
        return pagination ?? this.INIT_PAGINATION;
    }
    offsetPaginationFromParamMap(paramMap) {
        const paginationBase = this.paginationBaseFromParamMap(paramMap);
        const pageStr = paramMap.get('page');
        if (paginationBase && pageStr !== null) {
            const parsedPage = Number.parseInt(pageStr);
            if (Number.isInteger(parsedPage)) {
                const page = Math.max(parsedPage, 0);
                return new OffsetPaginationEvent(page, paginationBase.size, paginationBase.sort, paginationBase.sortDir);
            }
        }
        return undefined;
    }
    cursorPaginationFromParamMap(paramMap) {
        const paginationBase = this.paginationBaseFromParamMap(paramMap);
        const cursor = paramMap.get('cursor');
        if (paginationBase) {
            return new CursorPaginationEvent(cursor, paginationBase.size, paginationBase.sort, paginationBase.sortDir);
        }
        return undefined;
    }
    paginationBaseFromParamMap(paramMap) {
        const sizeStr = paramMap.get(propertyOf('size'));
        const sort = paramMap.get(propertyOf('sort'));
        const sortDir = paramMap.get(propertyOf('sortDir'));
        if (sizeStr !== null) {
            const parsedSize = Number.parseInt(sizeStr);
            if (Number.isInteger(parsedSize)) {
                const positiveSize = Math.max(parsedSize, 1);
                const size = Math.min(positiveSize, this.maxPaginationSize);
                if (sort !== null && sortDir !== null) {
                    return { size: size, sort, sortDir: sortDir === 'asc' ? 'asc' : 'desc' };
                }
                else {
                    return { size: size, sort: undefined, sortDir: undefined };
                }
            }
        }
        return undefined;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: QueryParamPaginationService, deps: [{ token: i1.ActivatedRoute }, { token: i2.QueryParamsNavigationQueueService }, { token: INIT_PAGINATION_EVENT_BASE_TOKEN, optional: true }, { token: PAGINATION_TYPE_TOKEN, optional: true }, { token: MAX_PAGINATION_SIZE_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: QueryParamPaginationService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: QueryParamPaginationService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.ActivatedRoute }, { type: i2.QueryParamsNavigationQueueService }, { type: PaginationBaseInit, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [INIT_PAGINATION_EVENT_BASE_TOKEN]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [PAGINATION_TYPE_TOKEN]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAX_PAGINATION_SIZE_TOKEN]
                }] }] });

/**
 * Generated bundle index. Do not edit.
 */

export { INIT_PAGINATION_EVENT_BASE_TOKEN, MAX_PAGINATION_SIZE_TOKEN, OffsetPaginationResolver, PAGINATION_TYPE_TOKEN, PaginationBaseInit, PaginationService, QueryParamPaginationService, createInitPagination, createPaginationManager };
//# sourceMappingURL=sentinel-common-pagination-services.mjs.map

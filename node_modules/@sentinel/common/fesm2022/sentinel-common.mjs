import { FormGroup, FormControl, Validators } from '@angular/forms';
import { Subject, merge, BehaviorSubject, timer } from 'rxjs';
import { map, distinctUntilChanged, startWith, switchMap, retryWhen } from 'rxjs/operators';
import * as i0 from '@angular/core';
import { Directive, Input } from '@angular/core';
import { HttpParams } from '@angular/common/http';
import { PaginatedResource, CursorPagination, OffsetPagination } from '@sentinel/common/pagination';

class DateRangeForm {
    constructor(dateRange) {
        this.formGroup = new FormGroup({
            from: new FormControl(dateRange?.from ?? null),
            to: new FormControl(dateRange?.to ?? null),
        }, { validators: dateOrderValidator });
    }
}
const dateOrderValidator = (control) => {
    let error = null;
    if (control.get('from')?.value instanceof Date && control.get('to')?.value instanceof Date) {
        const startTime = control.get('from')?.value;
        const endTime = control.get('to')?.value;
        if (startTime && endTime && startTime && startTime.valueOf() > endTime.valueOf()) {
            error = { dateTimeOrder: true };
        }
    }
    return error;
};

class BaseReactiveForm {
    constructor(formGroup) {
        this.dirtySubject$ = new Subject();
        this.formGroup = formGroup;
        this.valid$ = this.formGroup.statusChanges.pipe(map(() => this.formGroup.valid), distinctUntilChanged(), startWith(this.formGroup.valid));
        const dirtyFromForm$ = this.formGroup.statusChanges.pipe(map(() => this.formGroup.dirty));
        this.dirty$ = merge(dirtyFromForm$, this.dirtySubject$).pipe(distinctUntilChanged(), startWith(this.dirty));
    }
    get valid() {
        return this.formGroup.valid;
    }
    get dirty() {
        return this.formGroup.dirty;
    }
    set dirty(value) {
        value ? this.formGroup.markAsDirty() : this.formGroup.markAsPristine();
        this.dirtySubject$.next(value);
    }
    set isSaving(value) {
        value ? this.formGroup.disable({ emitEvent: false }) : this.formGroup.enable({ emitEvent: false });
    }
}

class SLetDirective {
    constructor(viewContainer, templateRef) {
        this.context = { sLet: null };
        viewContainer.createEmbeddedView(templateRef, this.context);
    }
    set sLet(value) {
        this.context.sLet = value;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: SLetDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.0", type: SLetDirective, isStandalone: true, selector: "[sLet]", inputs: { sLet: "sLet" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: SLetDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[sLet]',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }], propDecorators: { sLet: [{
                type: Input
            }] } });

/**
 * Util class merging multiple http params into one http params object
 */
class SentinelParamsMerger {
    /**
     * Merges multiple http params into one http params object
     * @param params list of http params object to be merged
     */
    static merge(params) {
        let resultParams = new HttpParams();
        params.forEach((param) => param.keys().forEach((key) => {
            const paramValue = param.get(key);
            if (paramValue) {
                resultParams = resultParams.set(key, paramValue);
            }
        }));
        return resultParams;
    }
}

class ResponseHeaderContentDispositionReader {
    static getFilenameFromResponse(resp, defaultFilename) {
        const contentDispHeader = resp.headers.get('content-disposition');
        if (!contentDispHeader) {
            return defaultFilename;
        }
        const splitOnSeparator = defaultFilename.split(';');
        if (splitOnSeparator.length <= 1) {
            return defaultFilename;
        }
        const splitOnKeyword = splitOnSeparator[1].split('filename');
        if (splitOnKeyword.length <= 1) {
            return defaultFilename;
        }
        const splitOnEqualSign = splitOnKeyword[1].split('=');
        if (splitOnEqualSign.length <= 1) {
            return defaultFilename;
        }
        return splitOnEqualSign[1].trim();
    }
}

/**
 * Holds resource state data in an observable.
 * Subscribe to resource$ to receive latest data updates.
 */
class ResourceService {
    constructor() {
        /**
         * True if server returned error response on the latest request, false otherwise
         * Change internally in extending service. Client should subscribe to the observable
         */
        this.hasErrorSubject$ = new BehaviorSubject(false);
        /**
         * True if server returned error response on the latest request, false otherwise
         * @contract must be updated every time new data are received
         */
        this.hasError$ = this.hasErrorSubject$.asObservable();
        /**
         * True if response to the latest request was not yet received
         * Change internally in extending service. Client should subscribe to the observable
         */
        this.isLoadingSubject$ = new BehaviorSubject(false);
        /**
         * True if response to the latest request was not yet received
         * @contract must be updated every time new data are received
         */
        this.isLoading$ = this.isLoadingSubject$.asObservable();
        /**
         * Resource data of generic type. Change internally in extending service.
         * Client should subscribe to the observable
         * @contract must be updated every time new data are received
         */
        this.resourceSubject$ = new BehaviorSubject(undefined);
        /**
         * Resource data of generic type. Change internally in extending service.
         * Client should subscribe to the observable
         * @contract must be updated every time new data are received
         */
        this.resource$ = this.resourceSubject$.asObservable();
    }
}

/**
 * Adds polling behaviour to resource service
 */
class ResourcePollingService extends ResourceService {
    constructor(pollPeriod = 5000) {
        super();
        /**
         * Observable triggering retry of polling after it was interrupted (e.g. by error)
         */
        this.retryPolling$ = new Subject();
        this.pollPeriod = pollPeriod;
        this.resource$ = merge(this.createPoll(), this.resourceSubject$.asObservable());
    }
    /**
     * Performs necessary operations and updates state of the service.
     * @contract Needs to update hasError subject and retry polling
     * if it was previously interrupted
     * @param params any other parameters required to update data in your concrete service
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onManualResourceRefresh(...params) {
        if (this.hasErrorSubject$.getValue()) {
            this.retryPolling$.next(true);
        }
        this.hasErrorSubject$.next(false);
    }
    /**
     * Creates poll observable using a timer. You can extend the behaviour by piping the observable and applying
     * RxJs operators on it (e.g. takeWhile to stop polling on specific conditions)
     * @param dueTime optionally set a due time when the timer should start. By default it equals to the
     * poll period as it is expected that the first request is made from the service or component
     * using the service (to properly set up pagination and all other possible params like ids etc)
     */
    createPoll(dueTime = this.pollPeriod) {
        return timer(dueTime, this.pollPeriod).pipe(switchMap(() => this.refreshResource()), retryWhen(() => this.retryPolling$));
    }
}

/**
 * Contains subjects and observables typically used when handling paginated data.
 * Subscribe to resource$ to receive latest data updates.
 */
class PaginatedElementsService {
    constructor(pageSize = 10) {
        /**
         * True if server returned error response on the latest request, false otherwise
         * Change internally in extending service. Client should subscribe to the observable
         */
        this.hasErrorSubject$ = new BehaviorSubject(false);
        /**
         * True if server returned error response on the latest request, false otherwise
         * @contract must be updated every time new data are received
         */
        this.hasError$ = this.hasErrorSubject$.asObservable();
        /**
         * True if response to the latest request was not yet received
         * Change internally in extending service. Client should subscribe to the observable
         */
        this.isLoadingSubject$ = new BehaviorSubject(false);
        /**
         * True if response to the latest request was not yet received
         * @contract must be updated every time new data are received
         */
        this.isLoading$ = this.isLoadingSubject$.asObservable();
        this.resourceSubject$ = new BehaviorSubject(this.initSubject(pageSize));
        this.resource$ = this.resourceSubject$.asObservable();
    }
}

class CursorPaginatedElementsService extends PaginatedElementsService {
    initSubject(pageSize) {
        return new PaginatedResource([], new CursorPagination(null, 0, pageSize, 0, null, null));
    }
}

/**
 * Adds polling behaviour to paginated elements service
 */
class PaginatedElementsPollingService extends PaginatedElementsService {
    constructor(defaultPaginationSize, pollPeriod) {
        super(defaultPaginationSize);
        /**
         * Observable triggering retry of polling after it was interrupted (e.g. by error)
         */
        this.retryPolling$ = new Subject();
        this.pollPeriod = pollPeriod;
        this.resource$ = merge(this.createPoll(), this.resourceSubject$.asObservable());
    }
    /**
     * Performs necessary operations and updates state of the service.
     * @contract Needs to update lastPagination attribute, hasError subject and retry polling
     * if it was previously interrupted
     * @param pagination new requested pagination
     * @param params any other parameters required to update data in your concrete service
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onManualResourceRefresh(pagination, ...params) {
        this.lastPagination = pagination;
        if (this.hasErrorSubject$.getValue()) {
            this.retryPolling$.next(true);
        }
        this.hasErrorSubject$.next(false);
    }
    /**
     * Creates poll observable using a timer. You can extend the behaviour by piping the observable and applying
     * RxJs operators on it (e.g. takeWhile to stop polling on specific conditions)
     * @param dueTime optionally set a due time when the timer should start. By default it equals to the
     * poll period as it is expected that the first request is made from the service or component
     * using the service (to properly set up pagination and all other possible params like ids etc)
     */
    createPoll(dueTime = this.pollPeriod) {
        return timer(dueTime, this.pollPeriod).pipe(switchMap(() => this.refreshResource()), retryWhen(() => this.retryPolling$));
    }
}

class CursorPaginatedElementsPollingService extends PaginatedElementsPollingService {
    initSubject(pageSize) {
        return new PaginatedResource([], new CursorPagination(null, 0, pageSize, 0, null, null));
    }
}

class OffsetPaginatedElementsService extends PaginatedElementsService {
    initSubject(pageSize) {
        return new PaginatedResource([], new OffsetPagination(0, 0, pageSize, 0, 0));
    }
}

class OffsetPaginatedElementsPollingService extends PaginatedElementsPollingService {
    initSubject(pageSize) {
        return new PaginatedResource([], new OffsetPagination(0, 0, pageSize, 0, 0));
    }
}

class SentinelValidators {
    static { this.noWhitespace = (control) => {
        const isWhitespace = (control.value || '').trim().length === 0;
        const isValid = !isWhitespace;
        return isValid ? null : { whitespace: true };
    }; }
    static { this.minDate = (minDate) => {
        return (control) => {
            const date = new Date(control.value);
            if (minDate.getTime() < date.getTime()) {
                return null;
            }
            else {
                return { minDate: { value: control.value, expected: minDate } };
            }
        };
    }; }
    static { this.maxDate = (maxDate) => {
        return (control) => {
            const date = new Date(control.value);
            if (maxDate.getTime() > date.getTime()) {
                return null;
            }
            else {
                return { maxDate: { value: control.value, expected: maxDate } };
            }
        };
    }; }
    static { this.min = (min) => {
        return Validators.min(min);
    }; }
    static { this.max = (max) => {
        return Validators.max(max);
    }; }
    static { this.required = (control) => {
        return Validators.required(control);
    }; }
    static { this.requiredTrue = (control) => {
        return Validators.requiredTrue(control);
    }; }
    static { this.email = (control) => {
        return Validators.email(control);
    }; }
    static { this.minLength = (minLength) => {
        return Validators.minLength(minLength);
    }; }
    static { this.maxLength = (maxLength) => {
        return Validators.maxLength(maxLength);
    }; }
    static { this.pattern = (pattern) => {
        return Validators.pattern(pattern);
    }; }
    static { this.nullValidator = (control) => {
        return Validators.nullValidator(control);
    }; }
    static { this.compose = (validators) => {
        return Validators.compose(validators);
    }; }
    static { this.composeAsync = (validators) => {
        return Validators.composeAsync(validators);
    }; }
}

/*
 * Public API Surface of sentinel-common
 */

/**
 * Generated bundle index. Do not edit.
 */

export { BaseReactiveForm, CursorPaginatedElementsPollingService, CursorPaginatedElementsService, DateRangeForm, OffsetPaginatedElementsPollingService, OffsetPaginatedElementsService, ResourcePollingService, ResourceService, ResponseHeaderContentDispositionReader, SLetDirective, SentinelParamsMerger, SentinelValidators, dateOrderValidator };
//# sourceMappingURL=sentinel-common.mjs.map

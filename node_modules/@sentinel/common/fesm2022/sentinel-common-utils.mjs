import { Router } from '@angular/router';
import * as i0 from '@angular/core';
import { inject, Injectable } from '@angular/core';

const ENTITY_NOT_LOADING_STATE = { isLoading: false };

function isArray(x) {
    return Array.isArray(x);
}
function hasValue(value) {
    return value !== undefined && value !== null;
}
function propertyOf(name) {
    return name.toString();
}
function trackById(index, item) {
    return item.id;
}
function trackByIndex(index) {
    return index;
}
/**
 * Tries to match string value to one of the keys of enum. Returns undefined if it fails to match
 */
const enumFromValue = (enumObj, val) => {
    const enumName = Object.keys(enumObj).find((k) => enumObj[k] === val);
    return !enumName ? undefined : enumObj[enumName];
};
function toQueryParams(inputObject) {
    const params = {};
    const entries = Object.entries(inputObject);
    entries.forEach((entry) => (params[entry[0]] = entry[1]));
    return params;
}
function isLoading(state, id) {
    if ('id' in state) {
        return state.isLoading && id === state.id;
    }
    if ('ids' in state) {
        return state.isLoading && state.ids.includes(id);
    }
    return false;
}
function prettifyEnum(value) {
    if (value) {
        const lowercased = value.toLowerCase();
        const splitWords = lowercased.split('_');
        for (let i = 0; i < splitWords.length; i++) {
            splitWords[i] = splitWords[i].charAt(0).toUpperCase() + splitWords[i].slice(1);
        }
        return splitWords.join(' ');
    }
    else {
        return '';
    }
}
function slugify(value) {
    if (value === null || value === undefined) {
        return undefined;
    }
    else {
        return encodeURIComponent(value);
    }
}
function slugifyDate(value) {
    return value.valueOf();
}
function deslugify(value) {
    if (value === null || value === undefined) {
        return undefined;
    }
    else {
        return decodeURIComponent(value);
    }
}
function deslugifyTimestamp(value) {
    if (value === null || value === undefined) {
        return undefined;
    }
    else {
        const deslugified = deslugify(value);
        if (deslugified) {
            const timestamp = Number.parseInt(deslugified);
            if (!Number.isNaN(timestamp)) {
                return new Date(timestamp);
            }
        }
        return undefined;
    }
}
function isDate(value) {
    return (value instanceof Date || (typeof value === 'object' && Object.prototype.toString.call(value) === '[object Date]'));
}

class QueryParamsNavigationQueueService {
    constructor() {
        this.queue = Promise.resolve(true);
        this.router = inject(Router);
    }
    enqueue(queryParams) {
        const enqueue = async () => {
            try {
                await this.queue;
            }
            catch (error) {
                console.error(error);
            }
            return await this.router.navigate([], {
                queryParams: queryParams,
                queryParamsHandling: 'merge',
                replaceUrl: true,
            });
        };
        this.queue = enqueue();
        return this.queue;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: QueryParamsNavigationQueueService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: QueryParamsNavigationQueueService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: QueryParamsNavigationQueueService, decorators: [{
            type: Injectable
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { ENTITY_NOT_LOADING_STATE, QueryParamsNavigationQueueService, deslugify, deslugifyTimestamp, enumFromValue, hasValue, isArray, isDate, isLoading, prettifyEnum, propertyOf, slugify, slugifyDate, toQueryParams, trackById, trackByIndex };
//# sourceMappingURL=sentinel-common-utils.mjs.map

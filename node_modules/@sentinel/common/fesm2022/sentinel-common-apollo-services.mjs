import { BehaviorSubject, of, EMPTY, combineLatest } from 'rxjs';
import { distinctUntilChanged, tap, shareReplay, switchMap, map, concatMap, filter, catchError, take } from 'rxjs/operators';
import { ActivatedRoute } from '@angular/router';
import { ApolloResultType, createApolloContextErrorTitle, createApolloContextIgnoreErrorMessage, createApolloContextRetryable, ApolloOperationResultResolver, QueryCursorPaginationDataResolver, CursorPaginationConverter, DmtBaseOrderingConverter, CursorPaginationResolver } from '@sentinel/common/graphql';
import { inject } from '@angular/core';
import { NetworkStatus } from '@apollo/client/core';
import { PaginatedResource, CursorPaginationEvent, isCursorEvent } from '@sentinel/common/pagination';

class EntityModifyBaseService {
    constructor(entityName, notificationService) {
        this.notificationService = notificationService;
        this.isSavingSubject$ = new BehaviorSubject(false);
        this.isSaving$ = this.isSavingSubject$.asObservable().pipe(distinctUntilChanged());
        this.isLoadingSubject$ = new BehaviorSubject(true);
        this.isLoading$ = this.isLoadingSubject$.asObservable();
        this.hasErrorSubject$ = new BehaviorSubject(false);
        this.hasError$ = this.hasErrorSubject$.asObservable();
        this.activatedRoute = inject(ActivatedRoute);
        this.entityName = entityName;
        this.form$ = this.createForm().pipe(tap({
            next: () => this.isLoadingSubject$.next(false),
            error: () => {
                this.isLoadingSubject$.next(false);
                this.hasErrorSubject$.next(true);
            },
        }), shareReplay({ refCount: true, bufferSize: 1 }));
        this.canDeactivate$ = this.form$.pipe(switchMap((form) => form.dirty$), map((dirty) => !dirty), distinctUntilChanged());
    }
    cancel() {
        return this.form$.pipe(tap((form) => (form.dirty = false)), concatMap(() => this.handleCancel()));
    }
    handleSaveResult(form, result) {
        if (result.type === ApolloResultType.SUCCESS) {
            form.dirty = false;
            this.notificationService.emit('success', this.createSuccessSaveMessage());
            return this.onSaveSuccess();
        }
        else {
            return this.onSaveError();
        }
    }
}

class EditEntityService extends EntityModifyBaseService {
    constructor(entityName, notificationService) {
        super(entityName, notificationService);
        this.notificationService = notificationService;
    }
    save() {
        return this.form$.pipe(concatMap((form) => (form.valid ? this.validFormSave(form) : of(false))));
    }
    createSuccessSaveMessage() {
        return `${this.entityName} was updated`;
    }
    createErrorSaveMessage() {
        const lowerCasedEntity = this.entityName.toLowerCase();
        return `Updating ${lowerCasedEntity}`;
    }
    validFormSave(form) {
        this.isSavingSubject$.next(true);
        return this.updateEntity(form).pipe(concatMap((result) => this.handleSaveResult(form, result)), tap({
            next: () => this.isSavingSubject$.next(false),
            error: () => this.isSavingSubject$.next(false),
        }));
    }
}

class CreateEntityService extends EntityModifyBaseService {
    constructor(entityName, notificationService) {
        super(entityName, notificationService);
        this.notificationService = notificationService;
    }
    save() {
        return this.form$.pipe(concatMap((form) => (form.valid ? this.validFormSave() : of(false))));
    }
    createSuccessSaveMessage() {
        return `${this.entityName} was created`;
    }
    createErrorSaveMessage() {
        const lowerCasedEntity = this.entityName.toLowerCase();
        return `Creating ${lowerCasedEntity}`;
    }
    validFormSave() {
        return this.form$.pipe(tap(() => this.isSavingSubject$.next(true)), concatMap((form) => this.createEntity(form).pipe(concatMap((result) => this.handleSaveResult(form, result)))), tap({
            next: () => this.isSavingSubject$.next(false),
            error: () => this.isSavingSubject$.next(false),
        }));
    }
}

class CreateEditEntityService extends EntityModifyBaseService {
    constructor(entityName, notificationService) {
        super(entityName, notificationService);
        this.notificationService = notificationService;
        this.editMode = false;
    }
    createForm() {
        return this.getEntityId().pipe(tap((id) => (this.editMode = id !== undefined)), concatMap((id) => this.createFormFromEntityId(id)));
    }
    save() {
        return this.form$.pipe(tap(() => this.isSavingSubject$.next(true)), concatMap((form) => (form.valid ? this.createOrUpdateEntity(form) : EMPTY)), tap({
            next: () => this.isSavingSubject$.next(false),
            error: () => this.isSavingSubject$.next(false),
        }));
    }
    createOrUpdateEntity(form) {
        const save$ = this.editMode ? this.updateEntity(form) : this.createEntity(form);
        return save$.pipe(concatMap((result) => this.handleSaveResult(form, result)));
    }
    createSuccessSaveMessage() {
        return this.editMode ? `${this.entityName} was updated` : `${this.entityName} was created`;
    }
    createErrorSaveMessage() {
        const lowerCasedEntity = this.entityName.toLowerCase();
        return this.editMode ? `Updating ${lowerCasedEntity}` : `Creating ${lowerCasedEntity}`;
    }
}

const DEFAULT_OPTIONS = {
    fetchPolicy: 'network-only',
    pollInterval: undefined,
    retryable: true,
    ignoreErrorMessage: false,
};
class ApolloQueryService {
    constructor(getQuery, operationName, options) {
        this.getQuery = getQuery;
        this.initialized$ = new BehaviorSubject(false);
        this.isInErrorState = false;
        this.operationName = operationName;
        this.options = options ?? DEFAULT_OPTIONS;
        this.data$ = this.initialized$.pipe(shareReplay({ refCount: true }), switchMap(() => this.queryRef?.valueChanges.pipe(
        // ignoring all responses not containing data
        filter((queryRes) => queryRes.data !== undefined && queryRes.networkStatus === NetworkStatus.ready), map((queryRes) => this.toData(queryRes)), catchError(() => EMPTY)) ?? EMPTY));
        this.isRefetching$ = this.initialized$.pipe(switchMap(() => this.queryRef?.valueChanges.pipe(map((queryRes) => (queryRes.networkStatus === NetworkStatus.refetch && queryRes.loading) ||
            queryRes.error !== undefined ||
            false), catchError(() => of(false)), distinctUntilChanged()) ?? EMPTY));
        this.isLoading$ = this.initialized$.pipe(switchMap(() => this.loadingInternal$ ?? EMPTY));
        this.hasError$ = this.initialized$.pipe(switchMap(() => this.hasErrorInternal$ ?? EMPTY));
    }
    recoverAfterError() {
        this.initialize();
    }
    initialize() {
        this.initQueryWatch();
        this.initLoading();
        this.initHasError();
        this.initialized$.next(true);
    }
    initQueryWatch() {
        this.queryRef = this.getQuery.watch(this.variables, {
            useInitialLoading: true,
            pollInterval: this.options?.pollInterval ?? DEFAULT_OPTIONS.pollInterval,
            fetchPolicy: this.options.fetchPolicy ?? DEFAULT_OPTIONS.fetchPolicy,
            nextFetchPolicy: 'network-only',
            errorPolicy: 'all',
            returnPartialData: true,
            notifyOnNetworkStatusChange: true, // to get all updates on loading state
            context: {
                ...createApolloContextErrorTitle(this.operationName),
                ...createApolloContextIgnoreErrorMessage(this.options?.ignoreErrorMessage !== undefined
                    ? this.options.ignoreErrorMessage
                    : DEFAULT_OPTIONS.ignoreErrorMessage ?? false),
                ...createApolloContextRetryable(this.options?.retryable !== undefined ? this.options?.retryable : DEFAULT_OPTIONS.retryable ?? true),
            },
        });
    }
    update(updateVariables) {
        this.variables = this.createVariables(updateVariables);
        if (!this.initialized$.getValue()) {
            this.initialize();
        }
        if (this.isInErrorState) {
            this.initialize();
        }
        if (this.queryRef && this.variables) {
            this.queryRef.setVariables(this.variables);
        }
    }
    refetch(updateVariables) {
        if (this.queryRef) {
            this.queryRef.options.context = {
                ...this.queryRef.options.context,
                ...createApolloContextIgnoreErrorMessage(true),
            };
        }
        this.variables = this.createVariables(updateVariables);
        this.queryRef?.refetch(this.variables);
    }
    initLoading() {
        if (this.queryRef) {
            this.loadingInternal$ = this.queryRef.valueChanges.pipe(
            // we ignore refetch loadings before it causes bad ux.
            filter((queryRes) => queryRes.networkStatus !== NetworkStatus.refetch), map((queryRes) => queryRes.loading || queryRes.error !== undefined), catchError(() => of(false)), distinctUntilChanged());
        }
    }
    initHasError() {
        if (this.queryRef) {
            const ref = this.queryRef;
            this.hasErrorInternal$ = ref.valueChanges.pipe(map((queryRes) => this.hasError(queryRes)), catchError(() => of(true)), distinctUntilChanged(), tap((hasError) => (this.isInErrorState = hasError)));
        }
    }
    hasError(queryRes) {
        return (queryRes.error !== undefined || queryRes.errors !== undefined || queryRes.networkStatus === NetworkStatus.error);
    }
}

class ApolloEntitiesBaseService extends ApolloQueryService {
    constructor(getQuery, operationName, options) {
        super(getQuery, operationName, options);
        this.getQuery = getQuery;
    }
    toData(queryRes) {
        return this.toFragments(queryRes.data);
    }
}

class ApolloEntitiesService extends ApolloEntitiesBaseService {
    constructor(getQuery, operationName, options) {
        super(getQuery, operationName, options);
        this.getQuery = getQuery;
        this.initialize();
    }
}

class ApolloEntityPatchService {
    constructor(patchMutation) {
        this.patchMutation = patchMutation;
    }
    patch(event) {
        const vars = this.createVariables(event);
        return this.patchMutation
            .mutate(vars, {
            refetchQueries: this.refetchQueriesNames,
            awaitRefetchQueries: true,
            context: createApolloContextErrorTitle('Updating entity'),
        })
            .pipe(take(1), map((result) => ApolloOperationResultResolver.resolve(result)), catchError((err) => ApolloOperationResultResolver.handleError(err)));
    }
}

class ApolloPaginatedBaseService extends ApolloQueryService {
    constructor(getQuery, operationName, options) {
        super(getQuery, operationName, options);
        this.getQuery = getQuery;
        this.lastPaginationEvent = this.createInitialPaginationEvent();
    }
    update(event) {
        super.update(event);
        this.lastPaginationEvent = event.pagination;
    }
    toData(result) {
        const entities = this.toFragments(result.data);
        const pagination = this.createPaginationFromQueryResult(result);
        return new PaginatedResource(entities, pagination);
    }
}

class ApolloIdentifiableEntityBaseService extends ApolloQueryService {
    constructor(getQuery, operationName, options) {
        super(getQuery, operationName, options);
        this.getQuery = getQuery;
    }
    toData(queryRes) {
        return this.toFragment(queryRes.data);
    }
}

class ApolloIdentifiableEntityService extends ApolloIdentifiableEntityBaseService {
    constructor(getQuery, operationName, options) {
        super(getQuery, operationName, options);
        this.getQuery = getQuery;
        this.initialized = false;
    }
}

class ApolloIdentifiableRouterEntityService extends ApolloIdentifiableEntityBaseService {
    constructor(getQuery, operationName, options) {
        super(getQuery, operationName, options);
        this.getQuery = getQuery;
        this.activatedRoute = inject(ActivatedRoute);
        this.data$ = this.initVarsFromParamMap().pipe(switchMap(() => this.initialized$), shareReplay({ refCount: true }), concatMap(() => this.queryRef?.valueChanges.pipe(filter((queryRes) => queryRes.data !== undefined && queryRes.networkStatus === NetworkStatus.ready), map((queryRes) => this.toData(queryRes)), catchError(() => EMPTY)) ?? EMPTY));
    }
    initVarsFromParamMap() {
        return combineLatest([
            this.activatedRoute.paramMap,
            this.activatedRoute.queryParamMap,
            this.activatedRoute.data,
        ]).pipe(map((activatedRoute) => this.identifierFromRouteData(activatedRoute[0], activatedRoute[1], activatedRoute[2])), distinctUntilChanged(), map((identifier) => {
            if (identifier === null) {
                throw new Error('Failed to initialize from activatedRoute');
            }
            else {
                this.update(identifier);
            }
        }));
    }
}

class ApolloFilterableService extends ApolloEntitiesBaseService {
    constructor(getQuery, operationName, options) {
        super(getQuery, operationName, options);
        this.getQuery = getQuery;
    }
}

class ApolloPaginatedDmtService extends ApolloPaginatedBaseService {
    constructor(getQuery, operationName, options) {
        super(getQuery, operationName, options);
        this.getQuery = getQuery;
    }
    queryToPaginationData(query) {
        return QueryCursorPaginationDataResolver.resolve(this.getQueryResponse(query));
    }
    toFragments(query) {
        return this.getQueryResponse(query).data;
    }
    createInitialPaginationEvent() {
        return new CursorPaginationEvent(null, 0, undefined, undefined);
    }
    createPaginationVariables(paginationEvent) {
        if (isCursorEvent(paginationEvent)) {
            return CursorPaginationConverter.convert(paginationEvent);
        }
        else {
            throw TypeError('Unsupported type of pagination');
        }
    }
    createOrderVariables(sort, dir) {
        if (sort && sort !== '' && dir && dir !== '') {
            return DmtBaseOrderingConverter.fromSingleSort(this.strToOrderable(sort), dir);
        }
        else {
            return {};
        }
    }
    createPaginationFromQueryResult(result) {
        if (isCursorEvent(this.lastPaginationEvent)) {
            const paginationData = this.queryToPaginationData(result.data);
            return CursorPaginationResolver.resolve(paginationData, this.lastPaginationEvent);
        }
        else {
            throw TypeError('Unsupported pagination');
        }
    }
}

class ApolloPaginatedFilterableService extends ApolloPaginatedDmtService {
    constructor(getQuery, operationName, options) {
        super(getQuery, operationName, options);
        this.getQuery = getQuery;
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { ApolloEntitiesBaseService, ApolloEntitiesService, ApolloEntityPatchService, ApolloFilterableService, ApolloIdentifiableEntityBaseService, ApolloIdentifiableEntityService, ApolloIdentifiableRouterEntityService, ApolloPaginatedBaseService, ApolloPaginatedDmtService, ApolloPaginatedFilterableService, ApolloQueryService, CreateEditEntityService, CreateEntityService, EditEntityService, EntityModifyBaseService };
//# sourceMappingURL=sentinel-common-apollo-services.mjs.map

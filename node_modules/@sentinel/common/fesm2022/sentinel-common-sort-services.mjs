import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Optional, Inject } from '@angular/core';
import equal from 'fast-deep-equal/es6';
import { BehaviorSubject, from } from 'rxjs';
import { distinctUntilChanged, shareReplay, take, concatMap, map } from 'rxjs/operators';
import * as i1 from '@sentinel/common/utils';
import { toQueryParams } from '@sentinel/common/utils';
import * as i2 from '@angular/router';

const INIT_SORT_TOKEN = new InjectionToken('INIT_ORDER_TOKEN');

class SortService {
    constructor(initSort) {
        this.initSort = initSort;
        this.INIT_SORT = initSort ? initSort : { sort: undefined, sortDir: undefined };
        this.sortSubject$ = new BehaviorSubject(this.INIT_SORT);
        this.sort$ = this.sortSubject$.asObservable().pipe(distinctUntilChanged((prev, curr) => equal(prev, curr)), shareReplay({ refCount: true }));
    }
    get() {
        return this.sortSubject$.getValue();
    }
    update(sort) {
        this.sortSubject$.next({ ...sort });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: SortService, deps: [{ token: INIT_SORT_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: SortService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: SortService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [INIT_SORT_TOKEN]
                }] }] });

class QueryParamSortService extends SortService {
    constructor(queryParamsQueueService, activatedRoute, initSort) {
        super(initSort);
        this.queryParamsQueueService = queryParamsQueueService;
        this.activatedRoute = activatedRoute;
        this.initSort = initSort;
        this.sort$ = this.createSortObservable();
    }
    updateQueryParams(sort) {
        return from(this.queryParamsQueueService.enqueue(toQueryParams(sort)));
    }
    createSortObservable() {
        return this.fromRoute().pipe(take(1), concatMap(() => this.sortSubject$), distinctUntilChanged((prev, curr) => equal(prev, curr)), concatMap((sort) => this.updateQueryParams(sort).pipe(map(() => sort))), shareReplay({ refCount: true }));
    }
    fromRoute() {
        return this.activatedRoute.queryParamMap.pipe(take(1), map((paramMap) => this.sortFromParamMap(paramMap)));
    }
    sortFromParamMap(paramMap) {
        const sort = paramMap.get('sort');
        const sortDirStr = paramMap.get('sortDir');
        if (sort !== null && sortDirStr !== null) {
            const sortDir = sortDirStr === 'asc' ? 'asc' : 'desc';
            return { sort, sortDir };
        }
        return this.INIT_SORT;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: QueryParamSortService, deps: [{ token: i1.QueryParamsNavigationQueueService }, { token: i2.ActivatedRoute }, { token: INIT_SORT_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: QueryParamSortService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: QueryParamSortService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.QueryParamsNavigationQueueService }, { type: i2.ActivatedRoute }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [INIT_SORT_TOKEN]
                }] }] });

/**
 * Generated bundle index. Do not edit.
 */

export { INIT_SORT_TOKEN, QueryParamSortService, SortService };
//# sourceMappingURL=sentinel-common-sort-services.mjs.map

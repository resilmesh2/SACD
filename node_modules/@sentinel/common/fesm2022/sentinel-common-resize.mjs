import * as i0 from '@angular/core';
import { Injectable, EventEmitter, Directive, Output } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { Subject, share, fromEvent, mergeWith } from 'rxjs';
import { map, filter, distinctUntilChanged, throttleTime } from 'rxjs/operators';

/**
 * Resize Event provider of all registered elements
 */
const RESIZE_EVENTS_SUBJECT = new Subject();
/**
 * Observable instance of RESIZE_EVENTS_SUBJECT
 * @see RESIZE_EVENTS_SUBJECT
 */
const RESIZE_EVENTS = RESIZE_EVENTS_SUBJECT.pipe(share());
/**
 * Html Elements' Resize Observer
 */
const RESIZE_OBSERVER = new ResizeObserver((entries) => {
    entries.forEach((entry) => RESIZE_EVENTS_SUBJECT.next(entry));
});
/**
 * Mutation Event provider of all registered elements
 */
const MUTATION_EVENTS_SUBJECT = new Subject();
/**
 * Observable instance of MUTATION_EVENTS_SUBJECT
 * @see MUTATION_EVENTS_SUBJECT
 */
const MUTATION_EVENTS = MUTATION_EVENTS_SUBJECT.pipe(share());
/**
 * Html Elements' Mutation Observer
 */
const MUTATION_OBSERVER = new MutationObserver((records) => {
    records.forEach((record) => MUTATION_EVENTS_SUBJECT.next(record));
});
/**
 * Cache observed elements and observables
 */
const OBSERVER_CACHE = new WeakMap();
/**
 * Creates and registers resize observer for a window instance
 * @param target Target Window Object
 */
function windowResizeEventProvider(target) {
    let cache = OBSERVER_CACHE.get(target);
    if (!cache) {
        cache = fromEvent(target, 'resize').pipe(map(() => {
            if (target instanceof Window) {
                return { width: target.innerWidth, height: target.innerHeight };
            }
            else {
                throw new Error('Error');
            }
        }), share());
        OBSERVER_CACHE.set(target, cache);
    }
    return cache;
}
/**
 * Creates and registers resize observer for an HTMLElement instance
 * @param target Target Window Object
 */
function domElementResizeEventProvider(target) {
    let cache = OBSERVER_CACHE.get(target);
    if (!cache) {
        RESIZE_OBSERVER.observe(target);
        MUTATION_OBSERVER.observe(target, { attributes: true, characterData: true, subtree: true, childList: true });
        cache = RESIZE_EVENTS.pipe(filter((e) => e.target === target), map((entry) => ({ width: entry.contentRect.width, height: entry.contentRect.height })), mergeWith(MUTATION_EVENTS.pipe(filter((record) => record.type !== 'attributes'), map(() => ({ width: target.offsetWidth, height: target.offsetHeight })))), distinctUntilChanged(({ width, height }, next) => width === next.width && height === next.height), share());
        OBSERVER_CACHE.set(target, cache);
    }
    return cache;
}
class SentinelResizeObserver {
    /**
     * @param target Target to listen its resize events
     * @param throttleTime Time interval to throttle resize events
     * > The throttle time under 90ms will not work well because of performance prospects.
     * > It will fire much less event than expected.
     */
    constructor(target, throttleTime = 90) {
        this.target = target;
        this.throttleTime = throttleTime;
        /**
         * The buffer for the observables which are throttled by the same time
         */
        this.buffer = {};
        this.provider =
            target instanceof Window ? windowResizeEventProvider(target) : domElementResizeEventProvider(target);
    }
    /**
     * Base Resize Observable
     *
     * Fires on every resize event
     *
     */
    get resize() {
        return this.throttleBy(this.throttleTime);
    }
    /**
     * Returns throttled resize events by given time
     *
     * Set `time` argument to `0` if you want to catch all events
     *
     * @param time Time to throttle events
     */
    throttleBy(time) {
        if (time <= 0) {
            return this.provider;
        }
        if (!(time in this.buffer)) {
            this.buffer[time] = this.provider.pipe(throttleTime(time));
        }
        return this.buffer[time];
    }
}

class SentinelResizeManager {
    constructor(observerThrottleTime = 90) {
        this.observerThrottleTime = observerThrottleTime;
        this._buffer = new Map();
    }
    observe(target, throttleTime = this.observerThrottleTime) {
        const observer = this._buffer.get(target);
        if (observer) {
            return observer;
        }
        else {
            const newObserver = new SentinelResizeObserver(target, throttleTime);
            this._buffer.set(target, newObserver);
            return newObserver;
        }
    }
    get root() {
        return this.observe(window);
    }
}

class SentinelResizeService {
    constructor() {
        this.windowResize$ = SentinelResizeService.manager.root.resize;
    }
    static { this.manager = new SentinelResizeManager(0); }
    observe(target, throttleBy = 90) {
        return SentinelResizeService.manager.observe(target).throttleBy(throttleBy);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: SentinelResizeService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: SentinelResizeService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: SentinelResizeService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class SentinelResizeDirective {
    constructor(service, { nativeElement }, destroyRef) {
        this.destroyRef = destroyRef;
        this.sentinelResize = new EventEmitter();
        service
            .observe(nativeElement, 0)
            .pipe(takeUntilDestroyed(this.destroyRef))
            .subscribe((event) => {
            this.sentinelResize.emit(event);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: SentinelResizeDirective, deps: [{ token: SentinelResizeService }, { token: i0.ElementRef }, { token: i0.DestroyRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.0", type: SentinelResizeDirective, isStandalone: true, selector: "[sentinelResize]", outputs: { sentinelResize: "sentinelResize" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: SentinelResizeDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[sentinelResize]',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: SentinelResizeService }, { type: i0.ElementRef }, { type: i0.DestroyRef }], propDecorators: { sentinelResize: [{
                type: Output
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { SentinelResizeDirective, SentinelResizeManager, SentinelResizeObserver, SentinelResizeService };
//# sourceMappingURL=sentinel-common-resize.mjs.map

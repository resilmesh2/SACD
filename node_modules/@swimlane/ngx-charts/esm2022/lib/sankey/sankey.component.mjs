import { Component, Input, ViewEncapsulation, ChangeDetectionStrategy, ContentChild, Output, EventEmitter } from '@angular/core';
import { sankey, sankeyLeft, sankeyLinkHorizontal } from 'd3-sankey';
import { BaseChartComponent } from '../common/base-chart.component';
import { calculateViewDimensions } from '../common/view-dimensions.helper';
import { ColorHelper } from '../common/color.helper';
import { ScaleType } from '../common/types/scale-type.enum';
import { StyleTypes } from '../common/tooltip/style.type';
import { escapeLabel } from '../common/label.helper';
import { id } from '../utils/id';
import { TextAnchor } from '../common/types/text-anchor.enum';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "../common/tooltip/tooltip.directive";
import * as i3 from "../common/charts/chart.component";
export class SankeyComponent extends BaseChartComponent {
    constructor() {
        super(...arguments);
        this.showLabels = true;
        this.tooltipDisabled = false;
        this.activeEntries = [];
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.margin = [10, 10, 10, 10];
        this.scaleType = ScaleType.Ordinal;
        this.styleTypes = StyleTypes;
    }
    update() {
        super.update();
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            legendType: this.scaleType
        });
        const linkDefs = this.results;
        const nodeDefs = Array.from(new Set(linkDefs.flatMap(l => [l.source, l.target])), (name) => ({
            name,
            value: linkDefs.filter(l => l.source === name).reduce((acc, l) => acc + l.value, 0)
        }));
        // Configure generator
        const sankeyGenerator = sankey()
            .nodeId(d => d.name)
            .nodeAlign(sankeyLeft)
            .nodeWidth(15)
            .nodePadding(10)
            .extent([
            [1, 5],
            [this.dims.width - 1, this.dims.height - 5]
        ]);
        // Generate links and nodes
        const data = sankeyGenerator({
            nodes: nodeDefs.map(d => Object.assign({}, d)),
            links: linkDefs.map(d => Object.assign({}, d))
        });
        this.valueDomain = this.getValueDomain(data.nodes);
        this.setColors();
        this.nodeRects = data.nodes.map(node => {
            const rect = {
                x: node.x0,
                y: node.y0,
                height: node.y1 - node.y0,
                width: node.x1 - node.x0,
                fill: this.colors.getColor(node.name),
                tooltip: this.getNodeTooltipText(node),
                rx: 5,
                data: {
                    name: node.name,
                    value: node.value
                },
                transform: '',
                label: this.labelFormatting ? this.labelFormatting(node.name) : node.name,
                labelAnchor: TextAnchor.Start
            };
            rect.labelAnchor = this.getTextAnchor(node);
            rect.transform = `translate(${rect.x},${rect.y})`;
            return rect;
        });
        this.linkPaths = data.links.map(link => {
            const gradientId = 'mask' + id().toString();
            const linkPath = {
                path: sankeyLinkHorizontal()(link),
                strokeWidth: Math.max(1, link.width),
                tooltip: this.getLinkTooltipText(link.source, link.target, link.value),
                id: gradientId,
                gradientFill: `url(#${gradientId})`,
                source: link.source,
                target: link.target,
                startColor: this.colors.getColor(link.source.name),
                endColor: this.colors.getColor(link.target.name),
                data: {
                    source: link.source.name,
                    target: link.target.name,
                    value: link.value
                }
            };
            return linkPath;
        });
        this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
    }
    getNodeTooltipText(node) {
        return `
      <span class="tooltip-label">${escapeLabel(node.name)}</span>
      <span class="tooltip-val">${node.value.toLocaleString()}</span>
    `;
    }
    getLinkTooltipText(sourceNode, targetNode, value) {
        return `
      <span class="tooltip-label">${escapeLabel(sourceNode.name)} • ${escapeLabel(targetNode.name)}</span>
      <span class="tooltip-val">${value.toLocaleString()} (${(value / sourceNode.value).toLocaleString(undefined, {
            style: 'percent',
            maximumFractionDigits: 2
        })})</span>
    `;
    }
    getTextAnchor(node) {
        if (node.layer === 0) {
            return TextAnchor.Start;
        }
        else {
            return TextAnchor.End;
        }
    }
    onClick(data) {
        this.select.emit(data);
    }
    setColors() {
        this.colors = new ColorHelper(this.scheme, this.scaleType, this.valueDomain);
    }
    getValueDomain(nodes) {
        return nodes.map(n => n.name);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: SankeyComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.12", type: SankeyComponent, selector: "ngx-charts-sankey", inputs: { showLabels: "showLabels", gradient: "gradient", tooltipDisabled: "tooltipDisabled", activeEntries: "activeEntries", labelFormatting: "labelFormatting" }, outputs: { activate: "activate", deactivate: "deactivate" }, queries: [{ propertyName: "tooltipTemplate", first: true, predicate: ["tooltipTemplate"], descendants: true }], usesInheritance: true, ngImport: i0, template: `
    <ngx-charts-chart [view]="[width, height]" [animations]="animations">
      <svg:g [attr.transform]="transform" class="sankey chart">
        <svg:g
          *ngFor="let link of linkPaths"
          class="link"
          ngx-tooltip
          [tooltipDisabled]="tooltipDisabled"
          [tooltipType]="styleTypes.tooltip"
          [tooltipPlacement]="'top'"
          [tooltipTitle]="tooltipTemplate ? undefined : link.tooltip"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipContext]="link.data"
        >
          <svg:defs>
            <svg:linearGradient
              [attr.id]="link.id"
              gradientUnits="userSpaceOnUse"
              [attr.x1]="link.source.x1"
              [attr.x2]="link.target.x0"
            >
              <svg:stop offset="0%" [attr.stop-color]="link.startColor"></svg:stop>
              <svg:stop offset="100%" [attr.stop-color]="link.endColor"></svg:stop>
            </svg:linearGradient>
          </svg:defs>
          <svg:path
            [attr.d]="link.path"
            [attr.stroke]="link.gradientFill"
            [attr.stroke-width]="link.strokeWidth"
            stroke-opacity="0.5"
            fill="none"
            (click)="select.emit(link.data)"
            (mouseenter)="activate.emit(link.data)"
          ></svg:path>
        </svg:g>

        <svg:g *ngFor="let rect of nodeRects" [attr.transform]="rect.transform" class="node">
          <svg:rect
            [attr.x]="0"
            [attr.y]="0"
            [attr.width]="rect.width"
            [attr.height]="rect.height"
            [attr.fill]="rect.fill"
            ngx-tooltip
            [tooltipDisabled]="tooltipDisabled"
            [tooltipType]="styleTypes.tooltip"
            [tooltipPlacement]="'top'"
            [tooltipTitle]="tooltipTemplate ? undefined : rect.tooltip"
            [tooltipTemplate]="tooltipTemplate"
            [tooltipContext]="rect.data"
            (click)="select.emit(rect.data)"
            (mouseenter)="activate.emit(rect.data)"
          ></svg:rect>
        </svg:g>

        <svg:g *ngFor="let rect of nodeRects" [attr.transform]="rect.transform">
          <svg:text
            *ngIf="showLabels && rect.height > 15"
            class="label"
            [attr.x]="rect.width + 5"
            [attr.y]="rect.height / 2"
            [attr.text-anchor]="rect.labelAnchor"
            dy="0.35em"
            [attr.dx]="rect.labelAnchor === 'end' ? -25 : 0"
          >
            {{ rect.label }}
          </svg:text>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `, isInline: true, styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"], dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.TooltipDirective, selector: "[ngx-tooltip]", inputs: ["tooltipCssClass", "tooltipTitle", "tooltipAppendToBody", "tooltipSpacing", "tooltipDisabled", "tooltipShowCaret", "tooltipPlacement", "tooltipAlignment", "tooltipType", "tooltipCloseOnClickOutside", "tooltipCloseOnMouseLeave", "tooltipHideTimeout", "tooltipShowTimeout", "tooltipTemplate", "tooltipShowEvent", "tooltipContext", "tooltipImmediateExit"], outputs: ["show", "hide"] }, { kind: "component", type: i3.ChartComponent, selector: "ngx-charts-chart", inputs: ["view", "showLegend", "legendOptions", "legendType", "activeEntries", "animations"], outputs: ["legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: SankeyComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-charts-sankey', template: `
    <ngx-charts-chart [view]="[width, height]" [animations]="animations">
      <svg:g [attr.transform]="transform" class="sankey chart">
        <svg:g
          *ngFor="let link of linkPaths"
          class="link"
          ngx-tooltip
          [tooltipDisabled]="tooltipDisabled"
          [tooltipType]="styleTypes.tooltip"
          [tooltipPlacement]="'top'"
          [tooltipTitle]="tooltipTemplate ? undefined : link.tooltip"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipContext]="link.data"
        >
          <svg:defs>
            <svg:linearGradient
              [attr.id]="link.id"
              gradientUnits="userSpaceOnUse"
              [attr.x1]="link.source.x1"
              [attr.x2]="link.target.x0"
            >
              <svg:stop offset="0%" [attr.stop-color]="link.startColor"></svg:stop>
              <svg:stop offset="100%" [attr.stop-color]="link.endColor"></svg:stop>
            </svg:linearGradient>
          </svg:defs>
          <svg:path
            [attr.d]="link.path"
            [attr.stroke]="link.gradientFill"
            [attr.stroke-width]="link.strokeWidth"
            stroke-opacity="0.5"
            fill="none"
            (click)="select.emit(link.data)"
            (mouseenter)="activate.emit(link.data)"
          ></svg:path>
        </svg:g>

        <svg:g *ngFor="let rect of nodeRects" [attr.transform]="rect.transform" class="node">
          <svg:rect
            [attr.x]="0"
            [attr.y]="0"
            [attr.width]="rect.width"
            [attr.height]="rect.height"
            [attr.fill]="rect.fill"
            ngx-tooltip
            [tooltipDisabled]="tooltipDisabled"
            [tooltipType]="styleTypes.tooltip"
            [tooltipPlacement]="'top'"
            [tooltipTitle]="tooltipTemplate ? undefined : rect.tooltip"
            [tooltipTemplate]="tooltipTemplate"
            [tooltipContext]="rect.data"
            (click)="select.emit(rect.data)"
            (mouseenter)="activate.emit(rect.data)"
          ></svg:rect>
        </svg:g>

        <svg:g *ngFor="let rect of nodeRects" [attr.transform]="rect.transform">
          <svg:text
            *ngIf="showLabels && rect.height > 15"
            class="label"
            [attr.x]="rect.width + 5"
            [attr.y]="rect.height / 2"
            [attr.text-anchor]="rect.labelAnchor"
            dy="0.35em"
            [attr.dx]="rect.labelAnchor === 'end' ? -25 : 0"
          >
            {{ rect.label }}
          </svg:text>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"] }]
        }], propDecorators: { showLabels: [{
                type: Input
            }], gradient: [{
                type: Input
            }], tooltipDisabled: [{
                type: Input
            }], activeEntries: [{
                type: Input
            }], labelFormatting: [{
                type: Input
            }], activate: [{
                type: Output
            }], deactivate: [{
                type: Output
            }], tooltipTemplate: [{
                type: ContentChild,
                args: ['tooltipTemplate']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Fua2V5LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3N3aW1sYW5lL25neC1jaGFydHMvc3JjL2xpYi9zYW5rZXkvc2Fua2V5LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULEtBQUssRUFDTCxpQkFBaUIsRUFDakIsdUJBQXVCLEVBQ3ZCLFlBQVksRUFFWixNQUFNLEVBQ04sWUFBWSxFQUNiLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLG9CQUFvQixFQUFFLE1BQU0sV0FBVyxDQUFDO0FBRXJFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3BFLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQzNFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUVyRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDNUQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQzFELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNyRCxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ2pDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQzs7Ozs7QUE2RjlELE1BQU0sT0FBTyxlQUFnQixTQUFRLGtCQUFrQjtJQTdFdkQ7O1FBOEVXLGVBQVUsR0FBWSxJQUFJLENBQUM7UUFFM0Isb0JBQWUsR0FBWSxLQUFLLENBQUM7UUFDakMsa0JBQWEsR0FBVSxFQUFFLENBQUM7UUFHekIsYUFBUSxHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO1FBQ2pELGVBQVUsR0FBc0IsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQVE3RCxX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QXJCLEtBQUs7Z0JBQ0csZUFBZTtzQkFBdkIsS0FBSztnQkFFSSxRQUFRO3NCQUFqQixNQUFNO2dCQUNHLFVBQVU7c0JBQW5CLE1BQU07Z0JBRTBCLGVBQWU7c0JBQS9DLFlBQVk7dUJBQUMsaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb250ZW50Q2hpbGQsXG4gIFRlbXBsYXRlUmVmLFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHNhbmtleSwgc2Fua2V5TGVmdCwgc2Fua2V5TGlua0hvcml6b250YWwgfSBmcm9tICdkMy1zYW5rZXknO1xuXG5pbXBvcnQgeyBCYXNlQ2hhcnRDb21wb25lbnQgfSBmcm9tICcuLi9jb21tb24vYmFzZS1jaGFydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMgfSBmcm9tICcuLi9jb21tb24vdmlldy1kaW1lbnNpb25zLmhlbHBlcic7XG5pbXBvcnQgeyBDb2xvckhlbHBlciB9IGZyb20gJy4uL2NvbW1vbi9jb2xvci5oZWxwZXInO1xuaW1wb3J0IHsgVmlld0RpbWVuc2lvbnMgfSBmcm9tICcuLi9jb21tb24vdHlwZXMvdmlldy1kaW1lbnNpb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IFNjYWxlVHlwZSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcy9zY2FsZS10eXBlLmVudW0nO1xuaW1wb3J0IHsgU3R5bGVUeXBlcyB9IGZyb20gJy4uL2NvbW1vbi90b29sdGlwL3N0eWxlLnR5cGUnO1xuaW1wb3J0IHsgZXNjYXBlTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwuaGVscGVyJztcbmltcG9ydCB7IGlkIH0gZnJvbSAnLi4vdXRpbHMvaWQnO1xuaW1wb3J0IHsgVGV4dEFuY2hvciB9IGZyb20gJy4uL2NvbW1vbi90eXBlcy90ZXh0LWFuY2hvci5lbnVtJztcblxuaW50ZXJmYWNlIFJlY3RJdGVtIHtcbiAgZmlsbDogc3RyaW5nO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgcng6IG51bWJlcjtcbiAgd2lkdGg6IG51bWJlcjtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIGxhYmVsQW5jaG9yOiBzdHJpbmc7XG4gIHRvb2x0aXA6IHN0cmluZztcbiAgdHJhbnNmb3JtOiBzdHJpbmc7XG4gIGRhdGE6IGFueTtcbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1zYW5rZXknLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0IFt2aWV3XT1cIlt3aWR0aCwgaGVpZ2h0XVwiIFthbmltYXRpb25zXT1cImFuaW1hdGlvbnNcIj5cbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVwidHJhbnNmb3JtXCIgY2xhc3M9XCJzYW5rZXkgY2hhcnRcIj5cbiAgICAgICAgPHN2ZzpnXG4gICAgICAgICAgKm5nRm9yPVwibGV0IGxpbmsgb2YgbGlua1BhdGhzXCJcbiAgICAgICAgICBjbGFzcz1cImxpbmtcIlxuICAgICAgICAgIG5neC10b29sdGlwXG4gICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XCJ0b29sdGlwRGlzYWJsZWRcIlxuICAgICAgICAgIFt0b29sdGlwVHlwZV09XCJzdHlsZVR5cGVzLnRvb2x0aXBcIlxuICAgICAgICAgIFt0b29sdGlwUGxhY2VtZW50XT1cIid0b3AnXCJcbiAgICAgICAgICBbdG9vbHRpcFRpdGxlXT1cInRvb2x0aXBUZW1wbGF0ZSA/IHVuZGVmaW5lZCA6IGxpbmsudG9vbHRpcFwiXG4gICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XCJ0b29sdGlwVGVtcGxhdGVcIlxuICAgICAgICAgIFt0b29sdGlwQ29udGV4dF09XCJsaW5rLmRhdGFcIlxuICAgICAgICA+XG4gICAgICAgICAgPHN2ZzpkZWZzPlxuICAgICAgICAgICAgPHN2ZzpsaW5lYXJHcmFkaWVudFxuICAgICAgICAgICAgICBbYXR0ci5pZF09XCJsaW5rLmlkXCJcbiAgICAgICAgICAgICAgZ3JhZGllbnRVbml0cz1cInVzZXJTcGFjZU9uVXNlXCJcbiAgICAgICAgICAgICAgW2F0dHIueDFdPVwibGluay5zb3VyY2UueDFcIlxuICAgICAgICAgICAgICBbYXR0ci54Ml09XCJsaW5rLnRhcmdldC54MFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxzdmc6c3RvcCBvZmZzZXQ9XCIwJVwiIFthdHRyLnN0b3AtY29sb3JdPVwibGluay5zdGFydENvbG9yXCI+PC9zdmc6c3RvcD5cbiAgICAgICAgICAgICAgPHN2ZzpzdG9wIG9mZnNldD1cIjEwMCVcIiBbYXR0ci5zdG9wLWNvbG9yXT1cImxpbmsuZW5kQ29sb3JcIj48L3N2ZzpzdG9wPlxuICAgICAgICAgICAgPC9zdmc6bGluZWFyR3JhZGllbnQ+XG4gICAgICAgICAgPC9zdmc6ZGVmcz5cbiAgICAgICAgICA8c3ZnOnBhdGhcbiAgICAgICAgICAgIFthdHRyLmRdPVwibGluay5wYXRoXCJcbiAgICAgICAgICAgIFthdHRyLnN0cm9rZV09XCJsaW5rLmdyYWRpZW50RmlsbFwiXG4gICAgICAgICAgICBbYXR0ci5zdHJva2Utd2lkdGhdPVwibGluay5zdHJva2VXaWR0aFwiXG4gICAgICAgICAgICBzdHJva2Utb3BhY2l0eT1cIjAuNVwiXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAoY2xpY2spPVwic2VsZWN0LmVtaXQobGluay5kYXRhKVwiXG4gICAgICAgICAgICAobW91c2VlbnRlcik9XCJhY3RpdmF0ZS5lbWl0KGxpbmsuZGF0YSlcIlxuICAgICAgICAgID48L3N2ZzpwYXRoPlxuICAgICAgICA8L3N2ZzpnPlxuXG4gICAgICAgIDxzdmc6ZyAqbmdGb3I9XCJsZXQgcmVjdCBvZiBub2RlUmVjdHNcIiBbYXR0ci50cmFuc2Zvcm1dPVwicmVjdC50cmFuc2Zvcm1cIiBjbGFzcz1cIm5vZGVcIj5cbiAgICAgICAgICA8c3ZnOnJlY3RcbiAgICAgICAgICAgIFthdHRyLnhdPVwiMFwiXG4gICAgICAgICAgICBbYXR0ci55XT1cIjBcIlxuICAgICAgICAgICAgW2F0dHIud2lkdGhdPVwicmVjdC53aWR0aFwiXG4gICAgICAgICAgICBbYXR0ci5oZWlnaHRdPVwicmVjdC5oZWlnaHRcIlxuICAgICAgICAgICAgW2F0dHIuZmlsbF09XCJyZWN0LmZpbGxcIlxuICAgICAgICAgICAgbmd4LXRvb2x0aXBcbiAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVwidG9vbHRpcERpc2FibGVkXCJcbiAgICAgICAgICAgIFt0b29sdGlwVHlwZV09XCJzdHlsZVR5cGVzLnRvb2x0aXBcIlxuICAgICAgICAgICAgW3Rvb2x0aXBQbGFjZW1lbnRdPVwiJ3RvcCdcIlxuICAgICAgICAgICAgW3Rvb2x0aXBUaXRsZV09XCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiByZWN0LnRvb2x0aXBcIlxuICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XCJ0b29sdGlwVGVtcGxhdGVcIlxuICAgICAgICAgICAgW3Rvb2x0aXBDb250ZXh0XT1cInJlY3QuZGF0YVwiXG4gICAgICAgICAgICAoY2xpY2spPVwic2VsZWN0LmVtaXQocmVjdC5kYXRhKVwiXG4gICAgICAgICAgICAobW91c2VlbnRlcik9XCJhY3RpdmF0ZS5lbWl0KHJlY3QuZGF0YSlcIlxuICAgICAgICAgID48L3N2ZzpyZWN0PlxuICAgICAgICA8L3N2ZzpnPlxuXG4gICAgICAgIDxzdmc6ZyAqbmdGb3I9XCJsZXQgcmVjdCBvZiBub2RlUmVjdHNcIiBbYXR0ci50cmFuc2Zvcm1dPVwicmVjdC50cmFuc2Zvcm1cIj5cbiAgICAgICAgICA8c3ZnOnRleHRcbiAgICAgICAgICAgICpuZ0lmPVwic2hvd0xhYmVscyAmJiByZWN0LmhlaWdodCA+IDE1XCJcbiAgICAgICAgICAgIGNsYXNzPVwibGFiZWxcIlxuICAgICAgICAgICAgW2F0dHIueF09XCJyZWN0LndpZHRoICsgNVwiXG4gICAgICAgICAgICBbYXR0ci55XT1cInJlY3QuaGVpZ2h0IC8gMlwiXG4gICAgICAgICAgICBbYXR0ci50ZXh0LWFuY2hvcl09XCJyZWN0LmxhYmVsQW5jaG9yXCJcbiAgICAgICAgICAgIGR5PVwiMC4zNWVtXCJcbiAgICAgICAgICAgIFthdHRyLmR4XT1cInJlY3QubGFiZWxBbmNob3IgPT09ICdlbmQnID8gLTI1IDogMFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAge3sgcmVjdC5sYWJlbCB9fVxuICAgICAgICAgIDwvc3ZnOnRleHQ+XG4gICAgICAgIDwvc3ZnOmc+XG4gICAgICA8L3N2ZzpnPlxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHN0eWxlVXJsczogWycuLi9jb21tb24vYmFzZS1jaGFydC5jb21wb25lbnQuc2NzcyddLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIFNhbmtleUNvbXBvbmVudCBleHRlbmRzIEJhc2VDaGFydENvbXBvbmVudCB7XG4gIEBJbnB1dCgpIHNob3dMYWJlbHM6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoKSBncmFkaWVudDogYm9vbGVhbjtcbiAgQElucHV0KCkgdG9vbHRpcERpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgpIGFjdGl2ZUVudHJpZXM6IGFueVtdID0gW107XG4gIEBJbnB1dCgpIGxhYmVsRm9ybWF0dGluZzogYW55O1xuXG4gIEBPdXRwdXQoKSBhY3RpdmF0ZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoKSBkZWFjdGl2YXRlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBAQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnKSB0b29sdGlwVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgZGltczogVmlld0RpbWVuc2lvbnM7XG4gIGNvbG9yczogQ29sb3JIZWxwZXI7XG4gIGNvbG9yU2NhbGU6IGFueTtcbiAgdHJhbnNmb3JtOiBzdHJpbmc7XG4gIG1hcmdpbjogbnVtYmVyW10gPSBbMTAsIDEwLCAxMCwgMTBdO1xuICBzY2FsZVR5cGU6IFNjYWxlVHlwZSA9IFNjYWxlVHlwZS5PcmRpbmFsO1xuICB2YWx1ZURvbWFpbjogYW55W107XG4gIHN0eWxlVHlwZXMgPSBTdHlsZVR5cGVzO1xuXG4gIG5vZGVSZWN0czogUmVjdEl0ZW1bXTtcbiAgbGlua1BhdGhzOiBhbnlbXTtcblxuICB1cGRhdGUoKTogdm9pZCB7XG4gICAgc3VwZXIudXBkYXRlKCk7XG5cbiAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcbiAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NhbGVUeXBlIGFzIGFueVxuICAgIH0pO1xuXG4gICAgY29uc3QgbGlua0RlZnMgPSB0aGlzLnJlc3VsdHM7XG4gICAgY29uc3Qgbm9kZURlZnMgPSBBcnJheS5mcm9tKG5ldyBTZXQobGlua0RlZnMuZmxhdE1hcChsID0+IFtsLnNvdXJjZSwgbC50YXJnZXRdKSksIChuYW1lOiBzdHJpbmcpID0+ICh7XG4gICAgICBuYW1lLFxuICAgICAgdmFsdWU6IGxpbmtEZWZzLmZpbHRlcihsID0+IGwuc291cmNlID09PSBuYW1lKS5yZWR1Y2UoKGFjYywgbCkgPT4gYWNjICsgbC52YWx1ZSwgMClcbiAgICB9KSk7XG5cbiAgICAvLyBDb25maWd1cmUgZ2VuZXJhdG9yXG4gICAgY29uc3Qgc2Fua2V5R2VuZXJhdG9yID0gc2Fua2V5KClcbiAgICAgIC5ub2RlSWQoZCA9PiBkLm5hbWUpXG4gICAgICAubm9kZUFsaWduKHNhbmtleUxlZnQpXG4gICAgICAubm9kZVdpZHRoKDE1KVxuICAgICAgLm5vZGVQYWRkaW5nKDEwKVxuICAgICAgLmV4dGVudChbXG4gICAgICAgIFsxLCA1XSxcbiAgICAgICAgW3RoaXMuZGltcy53aWR0aCAtIDEsIHRoaXMuZGltcy5oZWlnaHQgLSA1XVxuICAgICAgXSk7XG5cbiAgICAvLyBHZW5lcmF0ZSBsaW5rcyBhbmQgbm9kZXNcbiAgICBjb25zdCBkYXRhID0gc2Fua2V5R2VuZXJhdG9yKHtcbiAgICAgIG5vZGVzOiBub2RlRGVmcy5tYXAoZCA9PiBPYmplY3QuYXNzaWduKHt9LCBkKSksXG4gICAgICBsaW5rczogbGlua0RlZnMubWFwKGQgPT4gT2JqZWN0LmFzc2lnbih7fSwgZCkpXG4gICAgfSk7XG5cbiAgICB0aGlzLnZhbHVlRG9tYWluID0gdGhpcy5nZXRWYWx1ZURvbWFpbihkYXRhLm5vZGVzKTtcbiAgICB0aGlzLnNldENvbG9ycygpO1xuXG4gICAgdGhpcy5ub2RlUmVjdHMgPSBkYXRhLm5vZGVzLm1hcChub2RlID0+IHtcbiAgICAgIGNvbnN0IHJlY3Q6IFJlY3RJdGVtID0ge1xuICAgICAgICB4OiBub2RlLngwLFxuICAgICAgICB5OiBub2RlLnkwLFxuICAgICAgICBoZWlnaHQ6IG5vZGUueTEgLSBub2RlLnkwLFxuICAgICAgICB3aWR0aDogbm9kZS54MSAtIG5vZGUueDAsXG4gICAgICAgIGZpbGw6IHRoaXMuY29sb3JzLmdldENvbG9yKG5vZGUubmFtZSksXG4gICAgICAgIHRvb2x0aXA6IHRoaXMuZ2V0Tm9kZVRvb2x0aXBUZXh0KG5vZGUpLFxuICAgICAgICByeDogNSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZVxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm06ICcnLFxuICAgICAgICBsYWJlbDogdGhpcy5sYWJlbEZvcm1hdHRpbmcgPyB0aGlzLmxhYmVsRm9ybWF0dGluZyhub2RlLm5hbWUpIDogbm9kZS5uYW1lLFxuICAgICAgICBsYWJlbEFuY2hvcjogVGV4dEFuY2hvci5TdGFydFxuICAgICAgfTtcbiAgICAgIHJlY3QubGFiZWxBbmNob3IgPSB0aGlzLmdldFRleHRBbmNob3Iobm9kZSk7XG4gICAgICByZWN0LnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtyZWN0Lnh9LCR7cmVjdC55fSlgO1xuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpbmtQYXRocyA9IGRhdGEubGlua3MubWFwKGxpbmsgPT4ge1xuICAgICAgY29uc3QgZ3JhZGllbnRJZCA9ICdtYXNrJyArIGlkKCkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IGxpbmtQYXRoID0ge1xuICAgICAgICBwYXRoOiBzYW5rZXlMaW5rSG9yaXpvbnRhbCgpKGxpbmspLFxuICAgICAgICBzdHJva2VXaWR0aDogTWF0aC5tYXgoMSwgbGluay53aWR0aCksXG4gICAgICAgIHRvb2x0aXA6IHRoaXMuZ2V0TGlua1Rvb2x0aXBUZXh0KGxpbmsuc291cmNlLCBsaW5rLnRhcmdldCwgbGluay52YWx1ZSksXG4gICAgICAgIGlkOiBncmFkaWVudElkLFxuICAgICAgICBncmFkaWVudEZpbGw6IGB1cmwoIyR7Z3JhZGllbnRJZH0pYCxcbiAgICAgICAgc291cmNlOiBsaW5rLnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiBsaW5rLnRhcmdldCxcbiAgICAgICAgc3RhcnRDb2xvcjogdGhpcy5jb2xvcnMuZ2V0Q29sb3IobGluay5zb3VyY2UubmFtZSksXG4gICAgICAgIGVuZENvbG9yOiB0aGlzLmNvbG9ycy5nZXRDb2xvcihsaW5rLnRhcmdldC5uYW1lKSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHNvdXJjZTogbGluay5zb3VyY2UubmFtZSxcbiAgICAgICAgICB0YXJnZXQ6IGxpbmsudGFyZ2V0Lm5hbWUsXG4gICAgICAgICAgdmFsdWU6IGxpbmsudmFsdWVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBsaW5rUGF0aDtcbiAgICB9KTtcblxuICAgIHRoaXMudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke3RoaXMuZGltcy54T2Zmc2V0fSAsICR7dGhpcy5tYXJnaW5bMF19KWA7XG4gIH1cblxuICBnZXROb2RlVG9vbHRpcFRleHQobm9kZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxzcGFuIGNsYXNzPVwidG9vbHRpcC1sYWJlbFwiPiR7ZXNjYXBlTGFiZWwobm9kZS5uYW1lKX08L3NwYW4+XG4gICAgICA8c3BhbiBjbGFzcz1cInRvb2x0aXAtdmFsXCI+JHtub2RlLnZhbHVlLnRvTG9jYWxlU3RyaW5nKCl9PC9zcGFuPlxuICAgIGA7XG4gIH1cblxuICBnZXRMaW5rVG9vbHRpcFRleHQoc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSwgdmFsdWU6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxzcGFuIGNsYXNzPVwidG9vbHRpcC1sYWJlbFwiPiR7ZXNjYXBlTGFiZWwoc291cmNlTm9kZS5uYW1lKX0g4oCiICR7ZXNjYXBlTGFiZWwodGFyZ2V0Tm9kZS5uYW1lKX08L3NwYW4+XG4gICAgICA8c3BhbiBjbGFzcz1cInRvb2x0aXAtdmFsXCI+JHt2YWx1ZS50b0xvY2FsZVN0cmluZygpfSAoJHsodmFsdWUgLyBzb3VyY2VOb2RlLnZhbHVlKS50b0xvY2FsZVN0cmluZyh1bmRlZmluZWQsIHtcbiAgICAgIHN0eWxlOiAncGVyY2VudCcsXG4gICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDJcbiAgICB9KX0pPC9zcGFuPlxuICAgIGA7XG4gIH1cblxuICBnZXRUZXh0QW5jaG9yKG5vZGUpOiBUZXh0QW5jaG9yIHtcbiAgICBpZiAobm9kZS5sYXllciA9PT0gMCkge1xuICAgICAgcmV0dXJuIFRleHRBbmNob3IuU3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBUZXh0QW5jaG9yLkVuZDtcbiAgICB9XG4gIH1cblxuICBvbkNsaWNrKGRhdGEpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xuICB9XG5cbiAgc2V0Q29sb3JzKCk6IHZvaWQge1xuICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjYWxlVHlwZSwgdGhpcy52YWx1ZURvbWFpbik7XG4gIH1cblxuICBnZXRWYWx1ZURvbWFpbihub2Rlcyk6IGFueVtdIHtcbiAgICByZXR1cm4gbm9kZXMubWFwKG4gPT4gbi5uYW1lKTtcbiAgfVxufVxuIl19